第一个阶段（在系统引导时），内核初始化陷阱表，并且CPU记住它的位置以供随后使用。
内核通过特权指令来执行此操作
第二个阶段（运行进程时），在使用从陷阱返回指令开始执行进程之前，内核完成设置,将CPU切换到用户模式并开始运行该进程。
当进程希望发出系统调用时，它会重新陷入操作系统，然后再次通过从陷阱返回，将控制权还给进程。
该进程然后完成它的工作，并从main()返回,正确退出该程序（例如，通过调用exit()系统调用，这将陷入OS中）。
操作系统如何重新获得CPU的控制权（regain control），以便它可以在进程之间切换？

协作方式：等待系统调用
作系统相信系统的进程会合理运行。运行时间过长的进程被假定会定期放弃CPU，以便操作系统可以决定运行其他任务
果应用程序执行了某些非法操作，也会将控制转移给操作系统。例如，如果应用程序以0为除数，或者尝试访问应该无法访问的内存，就会陷入（trap）操作系统。操作系统将再次控制CPU（并可能终止违规进程
当进程陷入无限循环时，唯一的办法就是使用古老的解决方案来解决计算机系统中的所有问题—重新启动计算机
用时钟中断重新获得控制权


钟中断（timer interrupt）[M+63]。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理程序（interrupthandler）会运行。此时，操作系统重新获得CPU的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程
硬件在发生中断时有一定的责任，尤其是在中断发生时，要为正在运行的程序保存足够的状态，以便随后从陷阱返回指令能够正确恢复正在运行的程序。这一组操作与硬件在显式系统调用陷入内核时的行为非常相似，其中各种寄存器因此被保存（进入内核栈），因此从陷阱返回指令可以容易地恢复。
上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）
有两种类型的寄存器保存/恢复。第一种是发生时钟中断的时jj候。在这种情况下，运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈。第二种是当操作系统决定从A切换到B。在这种情况下，内核寄存器被软件（即OS）明确地保存，但这次被存储在该进程的进程结构的内存中。后一个操作让系统从好像刚刚由A陷入内核，变成好像刚刚由B陷入内核。

