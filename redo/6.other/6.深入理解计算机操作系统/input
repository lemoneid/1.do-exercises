ORG:更多地强调了对程序员的影响。例如 ，要反 过来考虑数据表示对 C 语言程序的数据类型 和操作的影响

ORG+:强调硬件对应用程序性能,代码优化 和改进C语言程序的内存性能

ICS+:系统级网络编程和并发编程

大部分的现代计算机系统都使用 ASCII 标准来 表示文本字符 ,这 种方式 实际上就是用
一个唯一的单字节 大小的 整数值 @来 表示每个字符
系统中所有的信息
——
 包括磁 盘文件 、内
存中的程序 、内存 中存放的用户 数据以及网络 上传送的数据 ,都 是由一串比特 表示的。区
分不同数据对象的唯一 方法是 我们读到这些数据对象时的 上下文。比如 ,在 不同的上下文
中 ,一个同样的 字节序列可能表示一个整数 、浮点数 、字符串或 者机器指令。

汇 编阶段。接下来,汇编器 (as) 将 hello. s 翻译成机器语言指令 ,把这些指令打包成
一 种叫 做可重 定位目 标程序 (relocatable object program) 的格式 ,并 将结果保存 在目标
文件 hello. 〇 中。hello. 〇 文件是一个二进制文件 ,它包含的 17 个字节 是函数 main
的指 令编码。如果我们在文本 编辑器中打开 hello. 〇 文件,将看 到一堆乱码。
链 接阶段。请 注意, hello 程序 调用了 printf 函数 ,它是每个 C 编译器都 提供 库中 的一个 函数。printf 函数存 在于一 个名为 printf .ÿ 的单独的预编译
d) 就负责处理这 种合并。结果就得到 hello 文件 ,它是一个可 执行目 标文件. 〇 程序中 。链
链 接阶段。请 注意, hello 程序 调用了 printf 函数 ,它是每个 C 编译器都 提供的
标准 C 库中 的一个 函数。printf 函数存 在于一 个名为 printf .ÿ 的单独的预编译
好了的目标文件中,而这个 文件必须以某种方式 合并到 我们的 hello. 〇 程序中 。链
接器 (Id) 就负责处理这 种合并。结果就得到 hello 文件 ,它是一个可 执行目 标文件
(或 者简称 为可执 行文件), 可以被 加载到内存中 ,由 系统执行。

缓 冲区溢 出错误是造成 大多数 网络和 Internet 服务 器上安
全漏洞 的主要原因。存在这 些错误 是因为 很少有 程序员能够理 解需要 限制从 不受信
任 的源接 收数据的数量 和格式。学习安全 编程的 第一步就是理 解数据 和控制 信息存
储在程 序栈上 的方式 会引起的后果


 系 统的硬 件组成
1. 总线
贯穿整个系统的是 一组电 子管道 ,称作总线 ,它携带信息 字节并 负责在 各个部 件间传
递 。通 常总线被设计成传送 定长的字节块 ,也 就是字 (word)。字中的 字节数(即 字长)是一
个基 本的系 统参数 ,各个系统 中都不 尽相同 。现 在的大多数机 器字长 要么是 4 个字节(32
位), 要么是 8 个字节 (64 位)。
. I/O 设备
1/〇( 输入 / 输出)设备是系统与外部世界的联 系通道 。我们的示例 系统包 括四个 I/O 设
备:作为用户输入的键盘 和鼠标 ,作 为用户 输出的显示器 ,以 及用于 长期存储数据 和程序
的磁盘驱动器(简单 地说就 是磁盘)。 最开始 ,可执行程序 hello 就存 放在磁 盘上。
每个
 I/O 设备都 通过一个控制 器或适 配器与 I/O 总线相连 。控制 器和适 配器之间的区

别主要 在于它们的封装方式 。控制器是 I/O 设备本 身或者 系统的 主印制电路板(通 常称作
主板)上的芯片组 。而适 配器则 是一块 插在主 板插槽 上的卡 。无论如何 ,它 们的功 能都是
在 I/O 总线和 I/O 设备之间传递 信息。

3. 主存
主存是一个临时存储设备,在处理器执行程序时 ,用来存放程序和程 序处理的数据。从
物理上 来说,主存是由一组 动态随机存取存储器 (DRAM) 芯片组 成的。从逻辑 上来说 ,存储
器是一个线性的字节数组,每个字 节都有 其唯一的地址(数组索引), 这些地 址是从 零开始
的。一般来说,组 成程序的每条机器指令都由不同数 量的字节构成。与 C 程序 变量相对应的
数据项的大小是根 据类型变化的。比如 ,在运行 Linux 的 X86-64 机器上 , short 类型的数据
需要 2 个字节, int 和 float 类型需要 4 个字节 ,而 long 和 double 类型需要 8 个宇节。
第 6 章将 具体介 绍存储 器技术 ,比如 DRAM 芯片 是如何 工作的 ,它们 又是如 何组合
起来构成主存的。

4. 处理器
中央处 理单元
 (CPU), 简称处 理器,是解释 (或执行) 存储在主存 中指令的引擎 。处理
器的核心是一个大小为一个 字的存 储设备(或 寄存器 ), 称 为程序 计数器(PC)。 在 任何时
刻, PC 都指向主存中的某条 机器语言指令(即含有该条指令 的地址 )。 e
从系统通电 开始,直到系统断电 ,处 理器一 直在不 断地执 行程序 计数器 指向的 指令,
再更新 程序计数器,使其指向下一条指令。处理 器看上 去是按 照一个 非常简 单的指令执行
模型来操作的,这个模型是由指令 集架构决定的 。在这个模型中 ,指 令按照 严格的顺序执
行 ,而执行一条指令包 含执行 一系列 的步骤。处 理器 从程序 计数器 指向的 内存处读取指

令 ,解释指令中的位,执行该指令指示的简单操作 ,然后更新 PCÿ 使 其指向 下一条指令,
而这条指令并不一定 和在内存中刚刚执行的指令 相邻。
这样的简 单操作并不多 ,它 们围绕 着主存 、寄存 器文件 (register file) 和算术/ 逻辑单
元 (ALU) 进行。寄存 器文件 是一个 小的存 储设备 ,由 一些单 个字长 的寄存 器组成 ,每个
寄存 器都有 唯一的 名字。 ALU 计 算新的 数据和 地址值。下 面是一 些简单 操作的 例子,
CPU 在指令的要 求下可 能会执行这些操作。
加载 :从主存复制一 个字节 或者一个字到 寄存器 ,以 覆盖寄存器 原来的内容。
* 存储:从寄存器复制一个字节或者一个字 到主存的某个位置,以覆盖 这个位 置上原
来的内容。
操作 :把两个寄存器的内容复制到 ALU, ALU 对这两个 字做算术运算 ,并 将结果
存放到一个寄 存器中 ,以覆 盖该寄存器中原来的内容。
跳转 :从指令本身中抽取 一个字 ,并 将这个字复制 到程序 计数器
 (PC) 中,以覆盖
PC 中原来 的值。
处 理器看上去是它的指 令集架构的简单实现 ,但是实际上现代处 理器使用了非 常复杂
的机 制来加速程序 的执行。因此 ,我 们将处理器的指令 集架构 和处理 器的微 体系结 构区分
开来:指令集 架构描述的是 每条机器代码指令的效果;而微体 系结构 描述的 是处理 器实际
上是如何实现的。在第 3 章研 究机器代码时 ,我 们考虑的是机 器的指 令集架构所提供的抽
象性 。第 4 章将更详细 地介绍处理器实际上是如何实现的 。第 5 章用一个模 型说明现代处
理器是如何工作的,从而能预测和优化机 器语言程序的性能。
